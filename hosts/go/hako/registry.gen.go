// Code generated by codegen.ts. DO NOT EDIT.
// Hako Version: 2e39c9d-dirty

package hako


import (
	"context"
	"fmt"

	"github.com/tetratelabs/wazero/api"
)


// Registry provides access to HAKO WASM exports.
type Registry struct {
	mod api.Module
	initializeFn api.Function
	throw api.Function
	throwError api.Function
	newError api.Function
	runtimeSetMemoryLimit api.Function
	runtimeComputeMemoryUsage api.Function
	runtimeDumpMemoryUsage api.Function
	runtimeJSThrow api.Function
	initTypeStripper api.Function
	cleanupTypeStripper api.Function
	stripTypes api.Function
	getUndefined api.Function
	getNull api.Function
	getFalse api.Function
	getTrue api.Function
	newRuntime api.Function
	freeRuntime api.Function
	setStripInfo api.Function
	getStripInfo api.Function
	newContext api.Function
	setContextData api.Function
	getContextData api.Function
	freeContext api.Function
	dupValuePointer api.Function
	freeValuePointer api.Function
	freeValuePointerRuntime api.Function
	malloc api.Function
	runtimeMalloc api.Function
	free api.Function
	runtimeFree api.Function
	freeCString api.Function
	newObject api.Function
	newObjectProto api.Function
	newArray api.Function
	newArrayBuffer api.Function
	newFloat64 api.Function
	getFloat64 api.Function
	newString api.Function
	toCString api.Function
	copyArrayBuffer api.Function
	eval api.Function
	newSymbol api.Function
	getSymbolDescriptionOrKey api.Function
	isGlobalSymbol api.Function
	isJobPending api.Function
	executePendingJob api.Function
	getProp api.Function
	getPropNumber api.Function
	setProp api.Function
	defineProp api.Function
	getOwnPropertyNames api.Function
	call api.Function
	getLastError api.Function
	dump api.Function
	getModuleNamespace api.Function
	typeOf api.Function
	isNull api.Function
	isUndefined api.Function
	isNullOrUndefined api.Function
	getLength api.Function
	isEqual api.Function
	getGlobalObject api.Function
	newPromiseCapability api.Function
	isPromise api.Function
	promiseState api.Function
	promiseResult api.Function
	buildIsDebug api.Function
	newFunction api.Function
	argvGetJSValueConstPointer api.Function
	runtimeEnableInterruptHandler api.Function
	runtimeDisableInterruptHandler api.Function
	runtimeEnableModuleLoader api.Function
	runtimeDisableModuleLoader api.Function
	bJSON_Encode api.Function
	bJSON_Decode api.Function
	isArray api.Function
	isTypedArray api.Function
	getTypedArrayType api.Function
	copyTypedArrayBuffer api.Function
	isArrayBuffer api.Function
	toJson api.Function
	parseJson api.Function
	isError api.Function
	isException api.Function
	setGCThreshold api.Function
	newBigInt api.Function
	getBigInt api.Function
	newBigUInt api.Function
	getBigUInt api.Function
	newDate api.Function
	isDate api.Function
	isMap api.Function
	isSet api.Function
	getDateTimestamp api.Function
	getClassID api.Function
	isInstanceOf api.Function
	buildInfo api.Function
	compileToByteCode api.Function
	evalByteCode api.Function
	newCModule api.Function
	addModuleExport api.Function
	setModuleExport api.Function
	getModuleName api.Function
	newClassID api.Function
	newClass api.Function
	setClassProto api.Function
	setConstructor api.Function
	newObjectClass api.Function
	setOpaque api.Function
	getOpaque api.Function
	newObjectProtoClass api.Function
	setModulePrivateValue api.Function
	getModulePrivateValue api.Function
	newTypedArray api.Function
	newTypedArrayWithBuffer api.Function
	runGC api.Function
	markValue api.Function
	setPromiseRejectionHandler api.Function
	clearPromiseRejectionHandler api.Function
}

// NewRegistry creates a new Registry from a WASM module.
func NewRegistry(mod api.Module) (*Registry, error) {
	r := &Registry{mod: mod}

	r.initializeFn = mod.ExportedFunction("_initialize")
	if r.initializeFn == nil {
		return nil, fmt.Errorf("missing export: _initialize")
	}
	r.throw = mod.ExportedFunction("HAKO_Throw")
	if r.throw == nil {
		return nil, fmt.Errorf("missing export: HAKO_Throw")
	}
	r.throwError = mod.ExportedFunction("HAKO_ThrowError")
	if r.throwError == nil {
		return nil, fmt.Errorf("missing export: HAKO_ThrowError")
	}
	r.newError = mod.ExportedFunction("HAKO_NewError")
	if r.newError == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewError")
	}
	r.runtimeSetMemoryLimit = mod.ExportedFunction("HAKO_RuntimeSetMemoryLimit")
	if r.runtimeSetMemoryLimit == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeSetMemoryLimit")
	}
	r.runtimeComputeMemoryUsage = mod.ExportedFunction("HAKO_RuntimeComputeMemoryUsage")
	if r.runtimeComputeMemoryUsage == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeComputeMemoryUsage")
	}
	r.runtimeDumpMemoryUsage = mod.ExportedFunction("HAKO_RuntimeDumpMemoryUsage")
	if r.runtimeDumpMemoryUsage == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeDumpMemoryUsage")
	}
	r.runtimeJSThrow = mod.ExportedFunction("HAKO_RuntimeJSThrow")
	if r.runtimeJSThrow == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeJSThrow")
	}
	r.initTypeStripper = mod.ExportedFunction("HAKO_InitTypeStripper")
	if r.initTypeStripper == nil {
		return nil, fmt.Errorf("missing export: HAKO_InitTypeStripper")
	}
	r.cleanupTypeStripper = mod.ExportedFunction("HAKO_CleanupTypeStripper")
	if r.cleanupTypeStripper == nil {
		return nil, fmt.Errorf("missing export: HAKO_CleanupTypeStripper")
	}
	r.stripTypes = mod.ExportedFunction("HAKO_StripTypes")
	if r.stripTypes == nil {
		return nil, fmt.Errorf("missing export: HAKO_StripTypes")
	}
	r.getUndefined = mod.ExportedFunction("HAKO_GetUndefined")
	if r.getUndefined == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetUndefined")
	}
	r.getNull = mod.ExportedFunction("HAKO_GetNull")
	if r.getNull == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetNull")
	}
	r.getFalse = mod.ExportedFunction("HAKO_GetFalse")
	if r.getFalse == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetFalse")
	}
	r.getTrue = mod.ExportedFunction("HAKO_GetTrue")
	if r.getTrue == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetTrue")
	}
	r.newRuntime = mod.ExportedFunction("HAKO_NewRuntime")
	if r.newRuntime == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewRuntime")
	}
	r.freeRuntime = mod.ExportedFunction("HAKO_FreeRuntime")
	if r.freeRuntime == nil {
		return nil, fmt.Errorf("missing export: HAKO_FreeRuntime")
	}
	r.setStripInfo = mod.ExportedFunction("HAKO_SetStripInfo")
	if r.setStripInfo == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetStripInfo")
	}
	r.getStripInfo = mod.ExportedFunction("HAKO_GetStripInfo")
	if r.getStripInfo == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetStripInfo")
	}
	r.newContext = mod.ExportedFunction("HAKO_NewContext")
	if r.newContext == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewContext")
	}
	r.setContextData = mod.ExportedFunction("HAKO_SetContextData")
	if r.setContextData == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetContextData")
	}
	r.getContextData = mod.ExportedFunction("HAKO_GetContextData")
	if r.getContextData == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetContextData")
	}
	r.freeContext = mod.ExportedFunction("HAKO_FreeContext")
	if r.freeContext == nil {
		return nil, fmt.Errorf("missing export: HAKO_FreeContext")
	}
	r.dupValuePointer = mod.ExportedFunction("HAKO_DupValuePointer")
	if r.dupValuePointer == nil {
		return nil, fmt.Errorf("missing export: HAKO_DupValuePointer")
	}
	r.freeValuePointer = mod.ExportedFunction("HAKO_FreeValuePointer")
	if r.freeValuePointer == nil {
		return nil, fmt.Errorf("missing export: HAKO_FreeValuePointer")
	}
	r.freeValuePointerRuntime = mod.ExportedFunction("HAKO_FreeValuePointerRuntime")
	if r.freeValuePointerRuntime == nil {
		return nil, fmt.Errorf("missing export: HAKO_FreeValuePointerRuntime")
	}
	r.malloc = mod.ExportedFunction("HAKO_Malloc")
	if r.malloc == nil {
		return nil, fmt.Errorf("missing export: HAKO_Malloc")
	}
	r.runtimeMalloc = mod.ExportedFunction("HAKO_RuntimeMalloc")
	if r.runtimeMalloc == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeMalloc")
	}
	r.free = mod.ExportedFunction("HAKO_Free")
	if r.free == nil {
		return nil, fmt.Errorf("missing export: HAKO_Free")
	}
	r.runtimeFree = mod.ExportedFunction("HAKO_RuntimeFree")
	if r.runtimeFree == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeFree")
	}
	r.freeCString = mod.ExportedFunction("HAKO_FreeCString")
	if r.freeCString == nil {
		return nil, fmt.Errorf("missing export: HAKO_FreeCString")
	}
	r.newObject = mod.ExportedFunction("HAKO_NewObject")
	if r.newObject == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewObject")
	}
	r.newObjectProto = mod.ExportedFunction("HAKO_NewObjectProto")
	if r.newObjectProto == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewObjectProto")
	}
	r.newArray = mod.ExportedFunction("HAKO_NewArray")
	if r.newArray == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewArray")
	}
	r.newArrayBuffer = mod.ExportedFunction("HAKO_NewArrayBuffer")
	if r.newArrayBuffer == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewArrayBuffer")
	}
	r.newFloat64 = mod.ExportedFunction("HAKO_NewFloat64")
	if r.newFloat64 == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewFloat64")
	}
	r.getFloat64 = mod.ExportedFunction("HAKO_GetFloat64")
	if r.getFloat64 == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetFloat64")
	}
	r.newString = mod.ExportedFunction("HAKO_NewString")
	if r.newString == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewString")
	}
	r.toCString = mod.ExportedFunction("HAKO_ToCString")
	if r.toCString == nil {
		return nil, fmt.Errorf("missing export: HAKO_ToCString")
	}
	r.copyArrayBuffer = mod.ExportedFunction("HAKO_CopyArrayBuffer")
	if r.copyArrayBuffer == nil {
		return nil, fmt.Errorf("missing export: HAKO_CopyArrayBuffer")
	}
	r.eval = mod.ExportedFunction("HAKO_Eval")
	if r.eval == nil {
		return nil, fmt.Errorf("missing export: HAKO_Eval")
	}
	r.newSymbol = mod.ExportedFunction("HAKO_NewSymbol")
	if r.newSymbol == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewSymbol")
	}
	r.getSymbolDescriptionOrKey = mod.ExportedFunction("HAKO_GetSymbolDescriptionOrKey")
	if r.getSymbolDescriptionOrKey == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetSymbolDescriptionOrKey")
	}
	r.isGlobalSymbol = mod.ExportedFunction("HAKO_IsGlobalSymbol")
	if r.isGlobalSymbol == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsGlobalSymbol")
	}
	r.isJobPending = mod.ExportedFunction("HAKO_IsJobPending")
	if r.isJobPending == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsJobPending")
	}
	r.executePendingJob = mod.ExportedFunction("HAKO_ExecutePendingJob")
	if r.executePendingJob == nil {
		return nil, fmt.Errorf("missing export: HAKO_ExecutePendingJob")
	}
	r.getProp = mod.ExportedFunction("HAKO_GetProp")
	if r.getProp == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetProp")
	}
	r.getPropNumber = mod.ExportedFunction("HAKO_GetPropNumber")
	if r.getPropNumber == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetPropNumber")
	}
	r.setProp = mod.ExportedFunction("HAKO_SetProp")
	if r.setProp == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetProp")
	}
	r.defineProp = mod.ExportedFunction("HAKO_DefineProp")
	if r.defineProp == nil {
		return nil, fmt.Errorf("missing export: HAKO_DefineProp")
	}
	r.getOwnPropertyNames = mod.ExportedFunction("HAKO_GetOwnPropertyNames")
	if r.getOwnPropertyNames == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetOwnPropertyNames")
	}
	r.call = mod.ExportedFunction("HAKO_Call")
	if r.call == nil {
		return nil, fmt.Errorf("missing export: HAKO_Call")
	}
	r.getLastError = mod.ExportedFunction("HAKO_GetLastError")
	if r.getLastError == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetLastError")
	}
	r.dump = mod.ExportedFunction("HAKO_Dump")
	if r.dump == nil {
		return nil, fmt.Errorf("missing export: HAKO_Dump")
	}
	r.getModuleNamespace = mod.ExportedFunction("HAKO_GetModuleNamespace")
	if r.getModuleNamespace == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetModuleNamespace")
	}
	r.typeOf = mod.ExportedFunction("HAKO_TypeOf")
	if r.typeOf == nil {
		return nil, fmt.Errorf("missing export: HAKO_TypeOf")
	}
	r.isNull = mod.ExportedFunction("HAKO_IsNull")
	if r.isNull == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsNull")
	}
	r.isUndefined = mod.ExportedFunction("HAKO_IsUndefined")
	if r.isUndefined == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsUndefined")
	}
	r.isNullOrUndefined = mod.ExportedFunction("HAKO_IsNullOrUndefined")
	if r.isNullOrUndefined == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsNullOrUndefined")
	}
	r.getLength = mod.ExportedFunction("HAKO_GetLength")
	if r.getLength == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetLength")
	}
	r.isEqual = mod.ExportedFunction("HAKO_IsEqual")
	if r.isEqual == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsEqual")
	}
	r.getGlobalObject = mod.ExportedFunction("HAKO_GetGlobalObject")
	if r.getGlobalObject == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetGlobalObject")
	}
	r.newPromiseCapability = mod.ExportedFunction("HAKO_NewPromiseCapability")
	if r.newPromiseCapability == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewPromiseCapability")
	}
	r.isPromise = mod.ExportedFunction("HAKO_IsPromise")
	if r.isPromise == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsPromise")
	}
	r.promiseState = mod.ExportedFunction("HAKO_PromiseState")
	if r.promiseState == nil {
		return nil, fmt.Errorf("missing export: HAKO_PromiseState")
	}
	r.promiseResult = mod.ExportedFunction("HAKO_PromiseResult")
	if r.promiseResult == nil {
		return nil, fmt.Errorf("missing export: HAKO_PromiseResult")
	}
	r.buildIsDebug = mod.ExportedFunction("HAKO_BuildIsDebug")
	if r.buildIsDebug == nil {
		return nil, fmt.Errorf("missing export: HAKO_BuildIsDebug")
	}
	r.newFunction = mod.ExportedFunction("HAKO_NewFunction")
	if r.newFunction == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewFunction")
	}
	r.argvGetJSValueConstPointer = mod.ExportedFunction("HAKO_ArgvGetJSValueConstPointer")
	if r.argvGetJSValueConstPointer == nil {
		return nil, fmt.Errorf("missing export: HAKO_ArgvGetJSValueConstPointer")
	}
	r.runtimeEnableInterruptHandler = mod.ExportedFunction("HAKO_RuntimeEnableInterruptHandler")
	if r.runtimeEnableInterruptHandler == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeEnableInterruptHandler")
	}
	r.runtimeDisableInterruptHandler = mod.ExportedFunction("HAKO_RuntimeDisableInterruptHandler")
	if r.runtimeDisableInterruptHandler == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeDisableInterruptHandler")
	}
	r.runtimeEnableModuleLoader = mod.ExportedFunction("HAKO_RuntimeEnableModuleLoader")
	if r.runtimeEnableModuleLoader == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeEnableModuleLoader")
	}
	r.runtimeDisableModuleLoader = mod.ExportedFunction("HAKO_RuntimeDisableModuleLoader")
	if r.runtimeDisableModuleLoader == nil {
		return nil, fmt.Errorf("missing export: HAKO_RuntimeDisableModuleLoader")
	}
	r.bJSON_Encode = mod.ExportedFunction("HAKO_BJSON_Encode")
	if r.bJSON_Encode == nil {
		return nil, fmt.Errorf("missing export: HAKO_BJSON_Encode")
	}
	r.bJSON_Decode = mod.ExportedFunction("HAKO_BJSON_Decode")
	if r.bJSON_Decode == nil {
		return nil, fmt.Errorf("missing export: HAKO_BJSON_Decode")
	}
	r.isArray = mod.ExportedFunction("HAKO_IsArray")
	if r.isArray == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsArray")
	}
	r.isTypedArray = mod.ExportedFunction("HAKO_IsTypedArray")
	if r.isTypedArray == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsTypedArray")
	}
	r.getTypedArrayType = mod.ExportedFunction("HAKO_GetTypedArrayType")
	if r.getTypedArrayType == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetTypedArrayType")
	}
	r.copyTypedArrayBuffer = mod.ExportedFunction("HAKO_CopyTypedArrayBuffer")
	if r.copyTypedArrayBuffer == nil {
		return nil, fmt.Errorf("missing export: HAKO_CopyTypedArrayBuffer")
	}
	r.isArrayBuffer = mod.ExportedFunction("HAKO_IsArrayBuffer")
	if r.isArrayBuffer == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsArrayBuffer")
	}
	r.toJson = mod.ExportedFunction("HAKO_ToJson")
	if r.toJson == nil {
		return nil, fmt.Errorf("missing export: HAKO_ToJson")
	}
	r.parseJson = mod.ExportedFunction("HAKO_ParseJson")
	if r.parseJson == nil {
		return nil, fmt.Errorf("missing export: HAKO_ParseJson")
	}
	r.isError = mod.ExportedFunction("HAKO_IsError")
	if r.isError == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsError")
	}
	r.isException = mod.ExportedFunction("HAKO_IsException")
	if r.isException == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsException")
	}
	r.setGCThreshold = mod.ExportedFunction("HAKO_SetGCThreshold")
	if r.setGCThreshold == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetGCThreshold")
	}
	r.newBigInt = mod.ExportedFunction("HAKO_NewBigInt")
	if r.newBigInt == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewBigInt")
	}
	r.getBigInt = mod.ExportedFunction("HAKO_GetBigInt")
	if r.getBigInt == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetBigInt")
	}
	r.newBigUInt = mod.ExportedFunction("HAKO_NewBigUInt")
	if r.newBigUInt == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewBigUInt")
	}
	r.getBigUInt = mod.ExportedFunction("HAKO_GetBigUInt")
	if r.getBigUInt == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetBigUInt")
	}
	r.newDate = mod.ExportedFunction("HAKO_NewDate")
	if r.newDate == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewDate")
	}
	r.isDate = mod.ExportedFunction("HAKO_IsDate")
	if r.isDate == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsDate")
	}
	r.isMap = mod.ExportedFunction("HAKO_IsMap")
	if r.isMap == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsMap")
	}
	r.isSet = mod.ExportedFunction("HAKO_IsSet")
	if r.isSet == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsSet")
	}
	r.getDateTimestamp = mod.ExportedFunction("HAKO_GetDateTimestamp")
	if r.getDateTimestamp == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetDateTimestamp")
	}
	r.getClassID = mod.ExportedFunction("HAKO_GetClassID")
	if r.getClassID == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetClassID")
	}
	r.isInstanceOf = mod.ExportedFunction("HAKO_IsInstanceOf")
	if r.isInstanceOf == nil {
		return nil, fmt.Errorf("missing export: HAKO_IsInstanceOf")
	}
	r.buildInfo = mod.ExportedFunction("HAKO_BuildInfo")
	if r.buildInfo == nil {
		return nil, fmt.Errorf("missing export: HAKO_BuildInfo")
	}
	r.compileToByteCode = mod.ExportedFunction("HAKO_CompileToByteCode")
	if r.compileToByteCode == nil {
		return nil, fmt.Errorf("missing export: HAKO_CompileToByteCode")
	}
	r.evalByteCode = mod.ExportedFunction("HAKO_EvalByteCode")
	if r.evalByteCode == nil {
		return nil, fmt.Errorf("missing export: HAKO_EvalByteCode")
	}
	r.newCModule = mod.ExportedFunction("HAKO_NewCModule")
	if r.newCModule == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewCModule")
	}
	r.addModuleExport = mod.ExportedFunction("HAKO_AddModuleExport")
	if r.addModuleExport == nil {
		return nil, fmt.Errorf("missing export: HAKO_AddModuleExport")
	}
	r.setModuleExport = mod.ExportedFunction("HAKO_SetModuleExport")
	if r.setModuleExport == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetModuleExport")
	}
	r.getModuleName = mod.ExportedFunction("HAKO_GetModuleName")
	if r.getModuleName == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetModuleName")
	}
	r.newClassID = mod.ExportedFunction("HAKO_NewClassID")
	if r.newClassID == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewClassID")
	}
	r.newClass = mod.ExportedFunction("HAKO_NewClass")
	if r.newClass == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewClass")
	}
	r.setClassProto = mod.ExportedFunction("HAKO_SetClassProto")
	if r.setClassProto == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetClassProto")
	}
	r.setConstructor = mod.ExportedFunction("HAKO_SetConstructor")
	if r.setConstructor == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetConstructor")
	}
	r.newObjectClass = mod.ExportedFunction("HAKO_NewObjectClass")
	if r.newObjectClass == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewObjectClass")
	}
	r.setOpaque = mod.ExportedFunction("HAKO_SetOpaque")
	if r.setOpaque == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetOpaque")
	}
	r.getOpaque = mod.ExportedFunction("HAKO_GetOpaque")
	if r.getOpaque == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetOpaque")
	}
	r.newObjectProtoClass = mod.ExportedFunction("HAKO_NewObjectProtoClass")
	if r.newObjectProtoClass == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewObjectProtoClass")
	}
	r.setModulePrivateValue = mod.ExportedFunction("HAKO_SetModulePrivateValue")
	if r.setModulePrivateValue == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetModulePrivateValue")
	}
	r.getModulePrivateValue = mod.ExportedFunction("HAKO_GetModulePrivateValue")
	if r.getModulePrivateValue == nil {
		return nil, fmt.Errorf("missing export: HAKO_GetModulePrivateValue")
	}
	r.newTypedArray = mod.ExportedFunction("HAKO_NewTypedArray")
	if r.newTypedArray == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewTypedArray")
	}
	r.newTypedArrayWithBuffer = mod.ExportedFunction("HAKO_NewTypedArrayWithBuffer")
	if r.newTypedArrayWithBuffer == nil {
		return nil, fmt.Errorf("missing export: HAKO_NewTypedArrayWithBuffer")
	}
	r.runGC = mod.ExportedFunction("HAKO_RunGC")
	if r.runGC == nil {
		return nil, fmt.Errorf("missing export: HAKO_RunGC")
	}
	r.markValue = mod.ExportedFunction("HAKO_MarkValue")
	if r.markValue == nil {
		return nil, fmt.Errorf("missing export: HAKO_MarkValue")
	}
	r.setPromiseRejectionHandler = mod.ExportedFunction("HAKO_SetPromiseRejectionHandler")
	if r.setPromiseRejectionHandler == nil {
		return nil, fmt.Errorf("missing export: HAKO_SetPromiseRejectionHandler")
	}
	r.clearPromiseRejectionHandler = mod.ExportedFunction("HAKO_ClearPromiseRejectionHandler")
	if r.clearPromiseRejectionHandler == nil {
		return nil, fmt.Errorf("missing export: HAKO_ClearPromiseRejectionHandler")
	}

	return r, nil
}

func (r *Registry) _initialize(ctx context.Context) {
	r.initializeFn.Call(ctx)
}

// Throw throws an error value
func (r *Registry) Throw(ctx context.Context, jsCtx ContextPtr, errVal ValuePtr) ValuePtr {
	results, _ := r.throw.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(errVal)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// ThrowError throws an error with specified type and message
func (r *Registry) ThrowError(ctx context.Context, jsCtx ContextPtr, error_type int32, message int32) ValuePtr {
	results, _ := r.throwError.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(error_type)), api.EncodeI32(int32(message)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewError creates a new Error object
func (r *Registry) NewError(ctx context.Context, jsCtx ContextPtr) ValuePtr {
	results, _ := r.newError.Call(ctx, api.EncodeI32(int32(jsCtx)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// RuntimeSetMemoryLimit sets memory limit for runtime
func (r *Registry) RuntimeSetMemoryLimit(ctx context.Context, rt RuntimePtr, limit int32) {
	r.runtimeSetMemoryLimit.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(limit)))
}

// RuntimeComputeMemoryUsage computes memory usage statistics
func (r *Registry) RuntimeComputeMemoryUsage(ctx context.Context, rt RuntimePtr, jsCtx ContextPtr) ValuePtr {
	results, _ := r.runtimeComputeMemoryUsage.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(jsCtx)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// RuntimeDumpMemoryUsage dumps memory usage as string
func (r *Registry) RuntimeDumpMemoryUsage(ctx context.Context, rt RuntimePtr) int32 {
	results, _ := r.runtimeDumpMemoryUsage.Call(ctx, api.EncodeI32(int32(rt)))
	return int32(api.DecodeI32(results[0]))
}

// RuntimeJSThrow throws a reference error
func (r *Registry) RuntimeJSThrow(ctx context.Context, jsCtx ContextPtr, message int32) {
	r.runtimeJSThrow.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(message)))
}

// InitTypeStripper initializes the TypeScript type stripper
func (r *Registry) InitTypeStripper(ctx context.Context, rt RuntimePtr) int32 {
	results, _ := r.initTypeStripper.Call(ctx, api.EncodeI32(int32(rt)))
	return int32(api.DecodeI32(results[0]))
}

// CleanupTypeStripper cleans up the TypeScript type stripper
func (r *Registry) CleanupTypeStripper(ctx context.Context, rt RuntimePtr) {
	r.cleanupTypeStripper.Call(ctx, api.EncodeI32(int32(rt)))
}

// StripTypes strips TypeScript type annotations from source code
func (r *Registry) StripTypes(ctx context.Context, rt RuntimePtr, typescript_source int32, javascript_out int32, javascript_len int32) int32 {
	results, _ := r.stripTypes.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(typescript_source)), api.EncodeI32(int32(javascript_out)), api.EncodeI32(int32(javascript_len)))
	return int32(api.DecodeI32(results[0]))
}

// GetUndefined gets pointer to undefined constant
func (r *Registry) GetUndefined(ctx context.Context) ValuePtr {
	results, _ := r.getUndefined.Call(ctx)
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetNull gets pointer to null constant
func (r *Registry) GetNull(ctx context.Context) ValuePtr {
	results, _ := r.getNull.Call(ctx)
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetFalse gets pointer to false constant
func (r *Registry) GetFalse(ctx context.Context) ValuePtr {
	results, _ := r.getFalse.Call(ctx)
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetTrue gets pointer to true constant
func (r *Registry) GetTrue(ctx context.Context) ValuePtr {
	results, _ := r.getTrue.Call(ctx)
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewRuntime creates a new runtime
func (r *Registry) NewRuntime(ctx context.Context) RuntimePtr {
	results, _ := r.newRuntime.Call(ctx)
	return RuntimePtr(api.DecodeI32(results[0]))
}

// FreeRuntime frees a runtime and all associated resources
func (r *Registry) FreeRuntime(ctx context.Context, rt RuntimePtr) {
	r.freeRuntime.Call(ctx, api.EncodeI32(int32(rt)))
}

// SetStripInfo configure debug info stripping for compiled code
func (r *Registry) SetStripInfo(ctx context.Context, rt RuntimePtr, flags int32) {
	r.setStripInfo.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(flags)))
}

// GetStripInfo get debug info stripping configuration
func (r *Registry) GetStripInfo(ctx context.Context, rt RuntimePtr) int32 {
	results, _ := r.getStripInfo.Call(ctx, api.EncodeI32(int32(rt)))
	return int32(api.DecodeI32(results[0]))
}

// NewContext creates a new context
func (r *Registry) NewContext(ctx context.Context, rt RuntimePtr, intrinsics int32) ContextPtr {
	results, _ := r.newContext.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(intrinsics)))
	return ContextPtr(api.DecodeI32(results[0]))
}

// SetContextData sets opaque data for context
func (r *Registry) SetContextData(ctx context.Context, jsCtx ContextPtr, data int32) {
	r.setContextData.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(data)))
}

// GetContextData gets opaque data from context
func (r *Registry) GetContextData(ctx context.Context, jsCtx ContextPtr) int32 {
	results, _ := r.getContextData.Call(ctx, api.EncodeI32(int32(jsCtx)))
	return int32(api.DecodeI32(results[0]))
}

// FreeContext frees a context and associated resources
func (r *Registry) FreeContext(ctx context.Context, jsCtx ContextPtr) {
	r.freeContext.Call(ctx, api.EncodeI32(int32(jsCtx)))
}

// DupValuePointer duplicates a value, incrementing refcount
func (r *Registry) DupValuePointer(ctx context.Context, jsCtx ContextPtr, val ValuePtr) ValuePtr {
	results, _ := r.dupValuePointer.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// FreeValuePointer frees a value pointer
func (r *Registry) FreeValuePointer(ctx context.Context, jsCtx ContextPtr, val ValuePtr) {
	r.freeValuePointer.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
}

// FreeValuePointerRuntime frees a value pointer using runtime
func (r *Registry) FreeValuePointerRuntime(ctx context.Context, rt RuntimePtr, val ValuePtr) {
	r.freeValuePointerRuntime.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(val)))
}

// Malloc allocates memory from context allocator
func (r *Registry) Malloc(ctx context.Context, jsCtx ContextPtr, size int32) int32 {
	results, _ := r.malloc.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(size)))
	return int32(api.DecodeI32(results[0]))
}

// RuntimeMalloc allocates memory from runtime allocator
func (r *Registry) RuntimeMalloc(ctx context.Context, rt RuntimePtr, size int32) int32 {
	results, _ := r.runtimeMalloc.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(size)))
	return int32(api.DecodeI32(results[0]))
}

// Free frees memory allocated by context
func (r *Registry) Free(ctx context.Context, jsCtx ContextPtr, ptr MemoryPtr) {
	r.free.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(ptr)))
}

// RuntimeFree frees memory allocated by runtime
func (r *Registry) RuntimeFree(ctx context.Context, rt RuntimePtr, ptr MemoryPtr) {
	r.runtimeFree.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(ptr)))
}

// FreeCString frees a C string returned from JS
func (r *Registry) FreeCString(ctx context.Context, jsCtx ContextPtr, str int32) {
	r.freeCString.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(str)))
}

// NewObject creates a new empty object
func (r *Registry) NewObject(ctx context.Context, jsCtx ContextPtr) ValuePtr {
	results, _ := r.newObject.Call(ctx, api.EncodeI32(int32(jsCtx)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewObjectProto creates a new object with prototype
func (r *Registry) NewObjectProto(ctx context.Context, jsCtx ContextPtr, proto ValuePtr) ValuePtr {
	results, _ := r.newObjectProto.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(proto)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewArray creates a new array
func (r *Registry) NewArray(ctx context.Context, jsCtx ContextPtr) ValuePtr {
	results, _ := r.newArray.Call(ctx, api.EncodeI32(int32(jsCtx)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewArrayBuffer creates an ArrayBuffer from existing memory
func (r *Registry) NewArrayBuffer(ctx context.Context, jsCtx ContextPtr, buffer MemoryPtr, len int32) ValuePtr {
	results, _ := r.newArrayBuffer.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(buffer)), api.EncodeI32(int32(len)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewFloat64 creates a new number value
func (r *Registry) NewFloat64(ctx context.Context, jsCtx ContextPtr, num float64) ValuePtr {
	results, _ := r.newFloat64.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeF64(float64(num)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetFloat64 converts a JavaScript value to a double
func (r *Registry) GetFloat64(ctx context.Context, jsCtx ContextPtr, val ValuePtr) float64 {
	results, _ := r.getFloat64.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return float64(api.DecodeF64(results[0]))
}

// NewString creates a new JavaScript string value
func (r *Registry) NewString(ctx context.Context, jsCtx ContextPtr, str int32) ValuePtr {
	results, _ := r.newString.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(str)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// ToCString converts a JavaScript value to a C string
func (r *Registry) ToCString(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.toCString.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// CopyArrayBuffer copies data from an ArrayBuffer
func (r *Registry) CopyArrayBuffer(ctx context.Context, jsCtx ContextPtr, val ValuePtr, out_len int32) int32 {
	results, _ := r.copyArrayBuffer.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)), api.EncodeI32(int32(out_len)))
	return int32(api.DecodeI32(results[0]))
}

// Eval evaluates JavaScript code
func (r *Registry) Eval(ctx context.Context, jsCtx ContextPtr, js_code int32, js_code_len int32, filename int32, detect_module int32, eval_flags int32) ValuePtr {
	results, _ := r.eval.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(js_code)), api.EncodeI32(int32(js_code_len)), api.EncodeI32(int32(filename)), api.EncodeI32(int32(detect_module)), api.EncodeI32(int32(eval_flags)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewSymbol creates a new symbol
func (r *Registry) NewSymbol(ctx context.Context, jsCtx ContextPtr, description int32, is_global int32) ValuePtr {
	results, _ := r.newSymbol.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(description)), api.EncodeI32(int32(is_global)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetSymbolDescriptionOrKey gets symbol description or key
func (r *Registry) GetSymbolDescriptionOrKey(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.getSymbolDescriptionOrKey.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsGlobalSymbol checks if symbol is global
func (r *Registry) IsGlobalSymbol(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.isGlobalSymbol.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsJobPending checks if promise jobs are pending
func (r *Registry) IsJobPending(ctx context.Context, rt RuntimePtr) int32 {
	results, _ := r.isJobPending.Call(ctx, api.EncodeI32(int32(rt)))
	return int32(api.DecodeI32(results[0]))
}

// ExecutePendingJob executes pending promise jobs
func (r *Registry) ExecutePendingJob(ctx context.Context, rt RuntimePtr, max_jobs_to_execute int32, out_last_job_ctx int32) int32 {
	results, _ := r.executePendingJob.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(max_jobs_to_execute)), api.EncodeI32(int32(out_last_job_ctx)))
	return int32(api.DecodeI32(results[0]))
}

// GetProp gets a property by name
func (r *Registry) GetProp(ctx context.Context, jsCtx ContextPtr, this_val ValuePtr, prop_name ValuePtr) ValuePtr {
	results, _ := r.getProp.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(this_val)), api.EncodeI32(int32(prop_name)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetPropNumber gets a property by numeric index
func (r *Registry) GetPropNumber(ctx context.Context, jsCtx ContextPtr, this_val ValuePtr, prop_index int32) ValuePtr {
	results, _ := r.getPropNumber.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(this_val)), api.EncodeI32(int32(prop_index)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// SetProp sets a property value
func (r *Registry) SetProp(ctx context.Context, jsCtx ContextPtr, this_val ValuePtr, prop_name ValuePtr, prop_val ValuePtr) int32 {
	results, _ := r.setProp.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(this_val)), api.EncodeI32(int32(prop_name)), api.EncodeI32(int32(prop_val)))
	return int32(api.DecodeI32(results[0]))
}

func (r *Registry) DefineProp(ctx context.Context, arg0 int32, arg1 int32, arg2 int32, arg3 int32, arg4 int32, arg5 int32, arg6 int32, arg7 int32, arg8 int32, arg9 int32, arg10 int32) int32 {
	results, _ := r.defineProp.Call(ctx, api.EncodeI32(int32(arg0)), api.EncodeI32(int32(arg1)), api.EncodeI32(int32(arg2)), api.EncodeI32(int32(arg3)), api.EncodeI32(int32(arg4)), api.EncodeI32(int32(arg5)), api.EncodeI32(int32(arg6)), api.EncodeI32(int32(arg7)), api.EncodeI32(int32(arg8)), api.EncodeI32(int32(arg9)), api.EncodeI32(int32(arg10)))
	return int32(api.DecodeI32(results[0]))
}

// GetOwnPropertyNames gets own property names from object
func (r *Registry) GetOwnPropertyNames(ctx context.Context, jsCtx ContextPtr, out_prop_ptrs int32, out_prop_len int32, obj ValuePtr, flags int32) ValuePtr {
	results, _ := r.getOwnPropertyNames.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(out_prop_ptrs)), api.EncodeI32(int32(out_prop_len)), api.EncodeI32(int32(obj)), api.EncodeI32(int32(flags)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// Call calls a JavaScript function
func (r *Registry) Call(ctx context.Context, jsCtx ContextPtr, func_obj ValuePtr, this_obj ValuePtr, argc int32, argv_ptrs int32) ValuePtr {
	results, _ := r.call.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(func_obj)), api.EncodeI32(int32(this_obj)), api.EncodeI32(int32(argc)), api.EncodeI32(int32(argv_ptrs)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetLastError gets pending exception from context
func (r *Registry) GetLastError(ctx context.Context, jsCtx ContextPtr, maybe_exception ValuePtr) ValuePtr {
	results, _ := r.getLastError.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(maybe_exception)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// Dump dumps a value to string (for debugging)
func (r *Registry) Dump(ctx context.Context, jsCtx ContextPtr, obj ValuePtr) int32 {
	results, _ := r.dump.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(obj)))
	return int32(api.DecodeI32(results[0]))
}

// GetModuleNamespace gets the namespace object of a module
func (r *Registry) GetModuleNamespace(ctx context.Context, jsCtx ContextPtr, module_func_obj ValuePtr) ValuePtr {
	results, _ := r.getModuleNamespace.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(module_func_obj)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// TypeOf gets the type of a JavaScript value
func (r *Registry) TypeOf(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.typeOf.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsNull checks if a value is null
func (r *Registry) IsNull(ctx context.Context, val ValuePtr) int32 {
	results, _ := r.isNull.Call(ctx, api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsUndefined checks if a value is undefined
func (r *Registry) IsUndefined(ctx context.Context, val ValuePtr) int32 {
	results, _ := r.isUndefined.Call(ctx, api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsNullOrUndefined checks if a value is null or undefined
func (r *Registry) IsNullOrUndefined(ctx context.Context, val ValuePtr) int32 {
	results, _ := r.isNullOrUndefined.Call(ctx, api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// GetLength gets length of array or string
func (r *Registry) GetLength(ctx context.Context, jsCtx ContextPtr, out_len int32, val ValuePtr) int32 {
	results, _ := r.getLength.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(out_len)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsEqual checks if two values are equal
func (r *Registry) IsEqual(ctx context.Context, jsCtx ContextPtr, a ValuePtr, b ValuePtr, op int32) int32 {
	results, _ := r.isEqual.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(a)), api.EncodeI32(int32(b)), api.EncodeI32(int32(op)))
	return int32(api.DecodeI32(results[0]))
}

// GetGlobalObject gets the global object
func (r *Registry) GetGlobalObject(ctx context.Context, jsCtx ContextPtr) ValuePtr {
	results, _ := r.getGlobalObject.Call(ctx, api.EncodeI32(int32(jsCtx)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewPromiseCapability creates a new promise with resolve/reject functions
func (r *Registry) NewPromiseCapability(ctx context.Context, jsCtx ContextPtr, out_resolve_funcs int32) ValuePtr {
	results, _ := r.newPromiseCapability.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(out_resolve_funcs)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// IsPromise checks if a value is a promise
func (r *Registry) IsPromise(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.isPromise.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// PromiseState gets the state of a promise
func (r *Registry) PromiseState(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.promiseState.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// PromiseResult gets the result/reason of a settled promise
func (r *Registry) PromiseResult(ctx context.Context, jsCtx ContextPtr, val ValuePtr) ValuePtr {
	results, _ := r.promiseResult.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// BuildIsDebug checks if this is a debug build
func (r *Registry) BuildIsDebug(ctx context.Context) int32 {
	results, _ := r.buildIsDebug.Call(ctx)
	return int32(api.DecodeI32(results[0]))
}

// NewFunction creates a new JavaScript function that calls back to host
func (r *Registry) NewFunction(ctx context.Context, jsCtx ContextPtr, func_id int32, name int32) ValuePtr {
	results, _ := r.newFunction.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(func_id)), api.EncodeI32(int32(name)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// ArgvGetJSValueConstPointer gets a pointer to an argv element
func (r *Registry) ArgvGetJSValueConstPointer(ctx context.Context, argv ValuePtr, index int32) ValuePtr {
	results, _ := r.argvGetJSValueConstPointer.Call(ctx, api.EncodeI32(int32(argv)), api.EncodeI32(int32(index)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// RuntimeEnableInterruptHandler enables interrupt handler for runtime
func (r *Registry) RuntimeEnableInterruptHandler(ctx context.Context, rt RuntimePtr, opaque int32) {
	r.runtimeEnableInterruptHandler.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(opaque)))
}

// RuntimeDisableInterruptHandler disables interrupt handler for runtime
func (r *Registry) RuntimeDisableInterruptHandler(ctx context.Context, rt RuntimePtr) {
	r.runtimeDisableInterruptHandler.Call(ctx, api.EncodeI32(int32(rt)))
}

// RuntimeEnableModuleLoader enables module loader for runtime
func (r *Registry) RuntimeEnableModuleLoader(ctx context.Context, rt RuntimePtr, use_custom_normalize int32, opaque int32) {
	r.runtimeEnableModuleLoader.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(use_custom_normalize)), api.EncodeI32(int32(opaque)))
}

// RuntimeDisableModuleLoader disables module loader for runtime
func (r *Registry) RuntimeDisableModuleLoader(ctx context.Context, rt RuntimePtr) {
	r.runtimeDisableModuleLoader.Call(ctx, api.EncodeI32(int32(rt)))
}

// BJSON_Encode encodes a value to binary JSON (QuickJS bytecode format)
func (r *Registry) BJSON_Encode(ctx context.Context, jsCtx ContextPtr, val ValuePtr, out_len int32) int32 {
	results, _ := r.bJSON_Encode.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)), api.EncodeI32(int32(out_len)))
	return int32(api.DecodeI32(results[0]))
}

// BJSON_Decode decodes a value from binary JSON
func (r *Registry) BJSON_Decode(ctx context.Context, jsCtx ContextPtr, buffer MemoryPtr, len int32) ValuePtr {
	results, _ := r.bJSON_Decode.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(buffer)), api.EncodeI32(int32(len)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// IsArray checks if a value is an array
func (r *Registry) IsArray(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.isArray.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsTypedArray checks if a value is a typed array
func (r *Registry) IsTypedArray(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.isTypedArray.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// GetTypedArrayType gets the typed array type
func (r *Registry) GetTypedArrayType(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.getTypedArrayType.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// CopyTypedArrayBuffer copies data from a TypedArray
func (r *Registry) CopyTypedArrayBuffer(ctx context.Context, jsCtx ContextPtr, val ValuePtr, out_len int32) int32 {
	results, _ := r.copyTypedArrayBuffer.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)), api.EncodeI32(int32(out_len)))
	return int32(api.DecodeI32(results[0]))
}

// IsArrayBuffer checks if a value is an ArrayBuffer
func (r *Registry) IsArrayBuffer(ctx context.Context, val ValuePtr) int32 {
	results, _ := r.isArrayBuffer.Call(ctx, api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// ToJson converts a value to JSON string
func (r *Registry) ToJson(ctx context.Context, jsCtx ContextPtr, val ValuePtr, indent int32) ValuePtr {
	results, _ := r.toJson.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)), api.EncodeI32(int32(indent)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// ParseJson parses a JSON string
func (r *Registry) ParseJson(ctx context.Context, jsCtx ContextPtr, json int32, json_len int32, filename int32) ValuePtr {
	results, _ := r.parseJson.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(json)), api.EncodeI32(int32(json_len)), api.EncodeI32(int32(filename)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// IsError checks if a value is an Error object
func (r *Registry) IsError(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int32 {
	results, _ := r.isError.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsException checks if a value is an exception
func (r *Registry) IsException(ctx context.Context, val ValuePtr) int32 {
	results, _ := r.isException.Call(ctx, api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// SetGCThreshold sets GC threshold for context
func (r *Registry) SetGCThreshold(ctx context.Context, jsCtx ContextPtr, threshold int64) {
	r.setGCThreshold.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI64(int64(threshold)))
}

// NewBigInt creates a new BigInt from 64-bit signed value
func (r *Registry) NewBigInt(ctx context.Context, jsCtx ContextPtr, value int64) ValuePtr {
	results, _ := r.newBigInt.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI64(int64(value)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetBigInt converts a JavaScript value to a 64-bit signed integer
func (r *Registry) GetBigInt(ctx context.Context, jsCtx ContextPtr, val ValuePtr) int64 {
	results, _ := r.getBigInt.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return int64(results[0])
}

// NewBigUInt creates a new BigInt from 64-bit unsigned value
func (r *Registry) NewBigUInt(ctx context.Context, jsCtx ContextPtr, value uint64) ValuePtr {
	results, _ := r.newBigUInt.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI64(int64(value)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// GetBigUInt converts a JavaScript value to a 64-bit unsigned integer
func (r *Registry) GetBigUInt(ctx context.Context, jsCtx ContextPtr, val ValuePtr) uint64 {
	results, _ := r.getBigUInt.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return uint64(results[0])
}

// NewDate creates a new Date object
func (r *Registry) NewDate(ctx context.Context, jsCtx ContextPtr, time float64) ValuePtr {
	results, _ := r.newDate.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeF64(float64(time)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// IsDate checks if a value is a Date object
func (r *Registry) IsDate(ctx context.Context, val ValuePtr) int32 {
	results, _ := r.isDate.Call(ctx, api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsMap checks if a value is a Map object
func (r *Registry) IsMap(ctx context.Context, val ValuePtr) int32 {
	results, _ := r.isMap.Call(ctx, api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// IsSet checks if a value is a Set object
func (r *Registry) IsSet(ctx context.Context, val ValuePtr) int32 {
	results, _ := r.isSet.Call(ctx, api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// GetDateTimestamp gets the timestamp from a Date object
func (r *Registry) GetDateTimestamp(ctx context.Context, jsCtx ContextPtr, val ValuePtr) float64 {
	results, _ := r.getDateTimestamp.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)))
	return float64(api.DecodeF64(results[0]))
}

// GetClassID gets the class ID of a value
func (r *Registry) GetClassID(ctx context.Context, val ValuePtr) ClassID {
	results, _ := r.getClassID.Call(ctx, api.EncodeI32(int32(val)))
	return ClassID(api.DecodeI32(results[0]))
}

// IsInstanceOf checks if a value is an instance of a constructor
func (r *Registry) IsInstanceOf(ctx context.Context, jsCtx ContextPtr, val ValuePtr, obj ValuePtr) int32 {
	results, _ := r.isInstanceOf.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(val)), api.EncodeI32(int32(obj)))
	return int32(api.DecodeI32(results[0]))
}

// BuildInfo gets build information
func (r *Registry) BuildInfo(ctx context.Context) int32 {
	results, _ := r.buildInfo.Call(ctx)
	return int32(api.DecodeI32(results[0]))
}

// CompileToByteCode compiles JavaScript code to bytecode
func (r *Registry) CompileToByteCode(ctx context.Context, jsCtx ContextPtr, js_code int32, js_code_len int32, filename int32, detect_module int32, flags int32, out_bytecode_len int32) int32 {
	results, _ := r.compileToByteCode.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(js_code)), api.EncodeI32(int32(js_code_len)), api.EncodeI32(int32(filename)), api.EncodeI32(int32(detect_module)), api.EncodeI32(int32(flags)), api.EncodeI32(int32(out_bytecode_len)))
	return int32(api.DecodeI32(results[0]))
}

// EvalByteCode evaluates compiled bytecode
func (r *Registry) EvalByteCode(ctx context.Context, jsCtx ContextPtr, bytecode_buf MemoryPtr, bytecode_len int32, load_only int32) ValuePtr {
	results, _ := r.evalByteCode.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(bytecode_buf)), api.EncodeI32(int32(bytecode_len)), api.EncodeI32(int32(load_only)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewCModule creates a new C module
func (r *Registry) NewCModule(ctx context.Context, jsCtx ContextPtr, name int32) ModuleDefPtr {
	results, _ := r.newCModule.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(name)))
	return ModuleDefPtr(api.DecodeI32(results[0]))
}

// AddModuleExport adds an export declaration to a C module
func (r *Registry) AddModuleExport(ctx context.Context, jsCtx ContextPtr, mod ModuleDefPtr, export_name int32) int32 {
	results, _ := r.addModuleExport.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(mod)), api.EncodeI32(int32(export_name)))
	return int32(api.DecodeI32(results[0]))
}

// SetModuleExport sets the value of a module export
func (r *Registry) SetModuleExport(ctx context.Context, jsCtx ContextPtr, mod ModuleDefPtr, export_name int32, val ValuePtr) int32 {
	results, _ := r.setModuleExport.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(mod)), api.EncodeI32(int32(export_name)), api.EncodeI32(int32(val)))
	return int32(api.DecodeI32(results[0]))
}

// GetModuleName gets the name of a module
func (r *Registry) GetModuleName(ctx context.Context, jsCtx ContextPtr, mod ModuleDefPtr) int32 {
	results, _ := r.getModuleName.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(mod)))
	return int32(api.DecodeI32(results[0]))
}

// NewClassID allocates a new class ID
func (r *Registry) NewClassID(ctx context.Context, out_class_id int32) ClassID {
	results, _ := r.newClassID.Call(ctx, api.EncodeI32(int32(out_class_id)))
	return ClassID(api.DecodeI32(results[0]))
}

// NewClass creates and registers a new class
func (r *Registry) NewClass(ctx context.Context, jsCtx ContextPtr, class_id ClassID, class_name int32, has_finalizer int32, has_gc_mark int32) ValuePtr {
	results, _ := r.newClass.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(class_id)), api.EncodeI32(int32(class_name)), api.EncodeI32(int32(has_finalizer)), api.EncodeI32(int32(has_gc_mark)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// SetClassProto sets the prototype for a class
func (r *Registry) SetClassProto(ctx context.Context, jsCtx ContextPtr, class_id ClassID, proto ValuePtr) {
	r.setClassProto.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(class_id)), api.EncodeI32(int32(proto)))
}

// SetConstructor links constructor and prototype (sets .prototype and .constructor)
func (r *Registry) SetConstructor(ctx context.Context, jsCtx ContextPtr, constructor ValuePtr, proto ValuePtr) {
	r.setConstructor.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(constructor)), api.EncodeI32(int32(proto)))
}

// NewObjectClass creates a new instance of a class
func (r *Registry) NewObjectClass(ctx context.Context, jsCtx ContextPtr, class_id ClassID) ValuePtr {
	results, _ := r.newObjectClass.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(class_id)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// SetOpaque sets opaque data on a class instance
func (r *Registry) SetOpaque(ctx context.Context, obj ValuePtr, opaque int32) {
	r.setOpaque.Call(ctx, api.EncodeI32(int32(obj)), api.EncodeI32(int32(opaque)))
}

// GetOpaque gets opaque data from a class instance
func (r *Registry) GetOpaque(ctx context.Context, jsCtx ContextPtr, obj ValuePtr, class_id ClassID) int32 {
	results, _ := r.getOpaque.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(obj)), api.EncodeI32(int32(class_id)))
	return int32(api.DecodeI32(results[0]))
}

// NewObjectProtoClass creates a new object with prototype and class
func (r *Registry) NewObjectProtoClass(ctx context.Context, jsCtx ContextPtr, proto ValuePtr, class_id ClassID) ValuePtr {
	results, _ := r.newObjectProtoClass.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(proto)), api.EncodeI32(int32(class_id)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// SetModulePrivateValue sets a private value on a module
func (r *Registry) SetModulePrivateValue(ctx context.Context, jsCtx ContextPtr, mod ModuleDefPtr, val ValuePtr) {
	r.setModulePrivateValue.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(mod)), api.EncodeI32(int32(val)))
}

// GetModulePrivateValue gets the private value from a module
func (r *Registry) GetModulePrivateValue(ctx context.Context, jsCtx ContextPtr, mod ModuleDefPtr) ValuePtr {
	results, _ := r.getModulePrivateValue.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(mod)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewTypedArray creates a new typed array with specified length
func (r *Registry) NewTypedArray(ctx context.Context, jsCtx ContextPtr, len int32, typ int32) ValuePtr {
	results, _ := r.newTypedArray.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(len)), api.EncodeI32(int32(typ)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// NewTypedArrayWithBuffer creates a typed array view on an ArrayBuffer
func (r *Registry) NewTypedArrayWithBuffer(ctx context.Context, jsCtx ContextPtr, array_buffer ValuePtr, byte_offset int32, len int32, typ int32) ValuePtr {
	results, _ := r.newTypedArrayWithBuffer.Call(ctx, api.EncodeI32(int32(jsCtx)), api.EncodeI32(int32(array_buffer)), api.EncodeI32(int32(byte_offset)), api.EncodeI32(int32(len)), api.EncodeI32(int32(typ)))
	return ValuePtr(api.DecodeI32(results[0]))
}

// RunGC runs garbage collection
func (r *Registry) RunGC(ctx context.Context, rt RuntimePtr) {
	r.runGC.Call(ctx, api.EncodeI32(int32(rt)))
}

// MarkValue marks a JavaScript value during garbage collection
func (r *Registry) MarkValue(ctx context.Context, rt RuntimePtr, val ValuePtr, mark_func int32) {
	r.markValue.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(val)), api.EncodeI32(int32(mark_func)))
}

// SetPromiseRejectionHandler sets promise rejection handler for runtime
func (r *Registry) SetPromiseRejectionHandler(ctx context.Context, rt RuntimePtr, opaque int32) {
	r.setPromiseRejectionHandler.Call(ctx, api.EncodeI32(int32(rt)), api.EncodeI32(int32(opaque)))
}

// ClearPromiseRejectionHandler clears promise rejection handler for runtime
func (r *Registry) ClearPromiseRejectionHandler(ctx context.Context, rt RuntimePtr) {
	r.clearPromiseRejectionHandler.Call(ctx, api.EncodeI32(int32(rt)))
}
